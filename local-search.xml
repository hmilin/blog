<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ESLint 和 Prettier 的使用</title>
    <link href="/blog/2021/04/20/code-check/"/>
    <url>/blog/2021/04/20/code-check/</url>
    
    <content type="html"><![CDATA[<h3 id="ESLint-和-Prettier-的区别"><a href="#ESLint-和-Prettier-的区别" class="headerlink" title="ESLint 和 Prettier 的区别"></a>ESLint 和 Prettier 的区别</h3><p>ESLint解决代码质量和代码格式问题</p><p>Prettier解决代码格式问题</p><blockquote><p>Linters usually contain not only code quality rules, but also stylistic rules. Most stylistic rules are unnecessary when using Prettier, but worse – they might conflict with Prettier!</p></blockquote><h3 id="Prettier使用"><a href="#Prettier使用" class="headerlink" title="Prettier使用"></a>Prettier使用</h3><ol><li>安装</li></ol><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">yarn <span class="hljs-keyword">add</span> --dev --<span class="hljs-keyword">exact</span> prettier<br><br></code></pre></td></tr></table></figure><ol start="2"><li>配置.prettierrc.json和.prettierignore文件，根据使用框架参考对应开源项目</li></ol><ol start="3"><li><p>编辑器安装prettier插件并配置使用方式</p></li><li><p>Git整合，确保代码提交的时候使用了格式化</p></li></ol><p>整合方式有4种</p><ul><li>lint-staged，</li><li>pretty-quick</li><li>pre-commit</li><li>precise-commits</li></ul><p>使用lint-staged</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">npx mrm lint-staged</span><br></code></pre></td></tr></table></figure><h3 id="ESLint使用"><a href="#ESLint使用" class="headerlink" title="ESLint使用"></a>ESLint使用</h3><h3 id="两者一起使用"><a href="#两者一起使用" class="headerlink" title="两者一起使用"></a>两者一起使用</h3><p>代码格式问题由Prettier接管，但是报错来源依旧是ESLint</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// .eslintrc    </span><br>&#123;      <br>    <span class="hljs-attr">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;prettier&quot;</span>],      <br>    <span class="hljs-attr">&quot;rules&quot;</span>: &#123;        <br>        <span class="hljs-attr">&quot;prettier/prettier&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>      <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>生成文件下载功能</title>
    <link href="/blog/2021/04/20/file-download/"/>
    <url>/blog/2021/04/20/file-download/</url>
    
    <content type="html"><![CDATA[<p>利用 a 标签 download 属性和 href 属性</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">element.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">href</span>&#x27;, &#x27;<span class="hljs-params">data</span>:<span class="hljs-params">text</span><span class="hljs-operator">/</span><span class="hljs-params">plain</span>;<span class="hljs-params">charset</span>=<span class="hljs-params">utf</span>-8,&#x27; + <span class="hljs-params">encodeURIComponent</span>(<span class="hljs-params">text</span>)</span>)<br></code></pre></td></tr></table></figure><p>具体实现代码为</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">on<span class="hljs-constructor">Download()</span> &#123;<br>    const ele = this.renderer.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">a</span>&#x27;)</span>;<br>    this.renderer.set<span class="hljs-constructor">Attribute(<span class="hljs-params">ele</span>, &#x27;<span class="hljs-params">href</span>&#x27;, &#x27;<span class="hljs-params">data</span>:<span class="hljs-params">text</span><span class="hljs-operator">/</span><span class="hljs-params">plain</span>;<span class="hljs-params">charset</span>=<span class="hljs-params">utf</span>-8,&#x27; + <span class="hljs-params">encodeURIComponent</span>(<span class="hljs-params">this</span>.<span class="hljs-params">logSearch1</span>.<span class="hljs-params">log</span>)</span>);<br>    this.renderer.set<span class="hljs-constructor">Attribute(<span class="hljs-params">ele</span>, &#x27;<span class="hljs-params">download</span>&#x27;, &#x27;<span class="hljs-params">log</span>.<span class="hljs-params">txt</span>&#x27;)</span>;<br>    document.body.append<span class="hljs-constructor">Child(<span class="hljs-params">ele</span>)</span>;<br>    ele.click<span class="hljs-literal">()</span>;<br>    document.body.remove<span class="hljs-constructor">Child(<span class="hljs-params">ele</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实现方式当遇到文本量多的时候会失效，因为href属性受浏览器对url长度的限制，超过限制长度会失效，可以使用blob对象，使用如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">on<span class="hljs-constructor">Download()</span> &#123;<br>    const ele = this.renderer.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">a</span>&#x27;)</span>;<br>    <span class="hljs-comment">// 修改部分</span><br>    const blob = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Blob([<span class="hljs-params">this</span>.<span class="hljs-params">logSearch1</span>.<span class="hljs-params">log</span>], &#123;<span class="hljs-params">type</span>: &#x27;<span class="hljs-params">text</span><span class="hljs-operator">/</span><span class="hljs-params">plain</span>&#x27;&#125;)</span>;<br>    this.renderer.set<span class="hljs-constructor">Attribute(<span class="hljs-params">ele</span>, &#x27;<span class="hljs-params">href</span>&#x27;, URL.<span class="hljs-params">createObjectURL</span>(<span class="hljs-params">blob</span>)</span>);<br>    <span class="hljs-comment">// 修改部分end</span><br>    this.renderer.set<span class="hljs-constructor">Attribute(<span class="hljs-params">ele</span>, &#x27;<span class="hljs-params">download</span>&#x27;, &#x27;<span class="hljs-params">log</span>.<span class="hljs-params">txt</span>&#x27;)</span>;<br>    document.body.append<span class="hljs-constructor">Child(<span class="hljs-params">ele</span>)</span>;<br>    ele.click<span class="hljs-literal">()</span>;<br>    document.body.remove<span class="hljs-constructor">Child(<span class="hljs-params">ele</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>乱七芭蕉</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git commit message规范</title>
    <link href="/blog/2021/04/20/git-commit-message/"/>
    <url>/blog/2021/04/20/git-commit-message/</url>
    
    <content type="html"><![CDATA[<ul><li>feat：提交新功能</li><li>fix：修复了bug</li><li>docs：只修改了文档</li><li>style：调整代码格式，未修改代码逻辑（比如修改空格、格式化、缺少分号等）</li><li>refactor：代码重构，既没修复bug也没有添加新功能</li><li>perf：性能优化，提高性能的代码更改</li><li>test：添加或修改代码测试</li><li>chore：对构建流程或辅助工具和依赖库（如文档生成等）的更改</li></ul>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
      <category>Angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git commit 修改</title>
    <link href="/blog/2021/04/20/git-rebase/"/>
    <url>/blog/2021/04/20/git-rebase/</url>
    
    <content type="html"><![CDATA[<p>工作过程中经常遇到已经开发好的功能有一些小变动，一个小功能多次提交看着总是不太舒服，需要使用cherry-pick的时也不方便。</p><h3 id="往上一个提交追加内容"><a href="#往上一个提交追加内容" class="headerlink" title="往上一个提交追加内容"></a>往上一个提交追加内容</h3><p>使用 git commit –amend  即可</p><h3 id="修改某一个历史提交"><a href="#修改某一个历史提交" class="headerlink" title="修改某一个历史提交"></a>修改某一个历史提交</h3><p>找到该提交的上一个commitId，执行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">git rebase &lt;commitId&gt; <span class="hljs-params">--interactive</span><br></code></pre></td></tr></table></figure><p>在vi中将pick改为edit，执行 git add ,然后 git commit –amend，最后执行 git rebase –continue</p><h3 id="将多个commit合并为一个"><a href="#将多个commit合并为一个" class="headerlink" title="将多个commit合并为一个"></a>将多个commit合并为一个</h3><p>Step 1.  git rebase -i   commit-id    会合并此次提交之后所有的提交为一个提交， 注意此次提交不会包含在内。</p><p>Step 2.  在 vim 编辑器中 会列出所有要合并的提交， 并修改内容,  保存并推出vim。<br>           pick  commit-id-1  commit-msg-1   =&gt;  pick  commit-id-1  commit-msg-1<br>           pick commit-id-2  commit-msg-2   =&gt;  s commit-id-2  commit-msg-2<br>           pick commit-id-3  commit-msg-3  =&gt;   s commit-id-3  commit-msg-3</p><p>step 3.  如果有冲突发生，解决冲突后并git add 然后运行  git rebase –continue,  在弹出的vim编辑器重重新编辑提交message. <br>            然后保存并退出。 如果要终止这次合并 git rebase –abort ,  git rebase –edit-todo 重新查看和编辑。</p><p>Step 4. 如果远程仓库有当前分支，则可能会让我们进行git pull 操作， 此时执行 git push origin :branch-name  删除远程分支， <br>           git branch –unset-upstream  将本地分支和远程分支进行解除关联。</p><p>Step 5. 最后运行 git push –set-upstream origin branch-name,  将本地合并的提交推送到远程仓库。 </p><ul><li><p>pick：简写p，表示启用该commitId</p></li><li><p>reword：简写r，使用该comitId，但是修改提交信息，修改后可以继续编辑后面的提交信息</p></li><li><p>edit：简写e，使用该commitId，停止合并该commitId</p></li><li><p>squash：简写s，使用该commitId，并将该commitId并入前一个commitId</p></li><li><p>drop：简写d，移除该commitId</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决node-sass安装失败问题</title>
    <link href="/blog/2021/04/20/node-sass/"/>
    <url>/blog/2021/04/20/node-sass/</url>
    
    <content type="html"><![CDATA[<h4 id="安装失败原因"><a href="#安装失败原因" class="headerlink" title="安装失败原因"></a>安装失败原因</h4><ul><li><h5 id="使用了国外镜像源，网络不通"><a href="#使用了国外镜像源，网络不通" class="headerlink" title="使用了国外镜像源，网络不通"></a>使用了国外镜像源，网络不通</h5><p>  删除yarn.lock或者pack-lock.json，然后设置全局镜像源为淘宝镜像源，再重新执行 yarn 或 npm install 即可</p></li><li><h5 id="node-sass版本和node版本不匹配"><a href="#node-sass版本和node版本不匹配" class="headerlink" title="node-sass版本和node版本不匹配"></a>node-sass版本和node版本不匹配</h5><p>  到<a href="https://www.npmjs.com/package/node-sass">node-sass的npm首页</a>查看版本对应</p></li><li><h5 id="binding-node下载失败"><a href="#binding-node下载失败" class="headerlink" title="binding.node下载失败"></a>binding.node下载失败</h5><p>  node-sass会下载二进制文件binding.node，默认源是github，需要修改变量sass_binary_site</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> npm<br>npm config set sass_binary_site https:<span class="hljs-regexp">//</span>npm.taobao.org<span class="hljs-regexp">/mirrors/</span>node-sass/<br><span class="hljs-regexp">//</span> yarn<br>yarn config set sass_binary_site https:<span class="hljs-regexp">//</span>npm.taobao.org<span class="hljs-regexp">/mirrors/</span>node-sass/<br></code></pre></td></tr></table></figure><p>  或者直接修改.npmrc 或者 .yarnrc</p></li><li><h5 id="提示网络环境没有python"><a href="#提示网络环境没有python" class="headerlink" title="提示网络环境没有python"></a>提示网络环境没有python</h5><p>  这一步通常是binding.node下载失败，开始执行本地构建导致的，目标应该放在解决binding.node安装问题</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>乱七芭蕉</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>rxjs学习记录</title>
    <link href="/blog/2021/04/20/rxjs/"/>
    <url>/blog/2021/04/20/rxjs/</url>
    
    <content type="html"><![CDATA[<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li><li>Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。</li><li>Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。</li><li>Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。</li><li>Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。</li><li>Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。</li></ul><h3 id="常用操作符"><a href="#常用操作符" class="headerlink" title="常用操作符"></a>常用操作符</h3><ul><li>of: 返回一个observable，依次发出传入的值</li><li>switchMap: 会取消上次发出的observable，通常和interval配合使用</li><li>mergeMap/flatMap: 与map的区别是能将返回结果打平</li><li>merge: 将多个Observable合并为一个</li><li>mergeAll: 收集并订阅所有Observable,map + mergeAll === mergeMap</li></ul><h3 id="关于取消订阅"><a href="#关于取消订阅" class="headerlink" title="关于取消订阅"></a>关于取消订阅</h3><h4 id="结束observable的方式"><a href="#结束observable的方式" class="headerlink" title="结束observable的方式"></a>结束observable的方式</h4><ol><li>Observable发送完数据之后执行Observable.onComplete()</li><li>Observable发生错误，执行Observable.OnError()</li><li>订阅者主动取消，subscription.unsubscribe()</li></ol><h4 id="angular中常见的Observable哪些需要取消订阅"><a href="#angular中常见的Observable哪些需要取消订阅" class="headerlink" title="angular中常见的Observable哪些需要取消订阅"></a>angular中常见的Observable哪些需要取消订阅</h4><ul><li>调用httpClient方法返回的Observable不需要取消订阅，因为发送数据之后，angular会调用Observable.onComplete()</li><li>使用AsyncPipe不需要取消订阅</li><li>通过 Subject，BehaviorSubject，AsyncSubject，ReplaySubject 在各个 Component 之间通信，需要调用 unsubscribe()取消订阅</li><li>使用rxjs自带的操作符不需要取消订阅</li></ul><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="处理多个http请求"><a href="#处理多个http请求" class="headerlink" title="处理多个http请求"></a>处理多个http请求</h4><p>遇到需要调用多个接口返回数据并统一处理的时候，可以使用forkJoin，类似Promise.all()</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle">GetDetails(projectId: string) &#123;<br>  const projects = <span class="hljs-keyword">this</span>._http.get&lt;<span class="hljs-keyword">any</span>&gt;(`<span class="hljs-regexp">/api/</span>factory<span class="hljs-regexp">/projects/</span>$&#123;projectId&#125;`);<br>  const powers = <span class="hljs-keyword">this</span>._http.get&lt;<span class="hljs-keyword">any</span>&gt;(`<span class="hljs-regexp">/api/</span>factory<span class="hljs-regexp">/projectpermissions/</span>projects<span class="hljs-regexp">/$&#123;projectId&#125;/u</span>serpermissions`);<br>  <span class="hljs-keyword">return</span> forkJoin([projects, powers]).pipe(<br>    map(values =&gt; &#123;<br>      const <span class="hljs-keyword">project</span> = values[<span class="hljs-number">0</span>];<br>      const <span class="hljs-keyword">power</span> = values[<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">return</span> &#123; ...<span class="hljs-keyword">project</span>, <span class="hljs-keyword">power</span> &#125;;<br>    &#125;)<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事件节流"><a href="#事件节流" class="headerlink" title="事件节流"></a>事件节流</h4><h4 id="subscribe嵌套问题"><a href="#subscribe嵌套问题" class="headerlink" title="subscribe嵌套问题"></a>subscribe嵌套问题</h4><h4 id="BehaviorSubject、ReplaySubject和AsyncSubject区别"><a href="#BehaviorSubject、ReplaySubject和AsyncSubject区别" class="headerlink" title="BehaviorSubject、ReplaySubject和AsyncSubject区别"></a>BehaviorSubject、ReplaySubject和AsyncSubject区别</h4><h5 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h5><p>可以设置初始值，并且订阅的时候会马上发送存储的最后一个值给订阅者</p><h5 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h5><p>可以实现重播，new ReplaySubject(存储几次广播，过期时间)</p><h5 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h5><p>一样可以存储数据，但是只会在Observable结束时发送数据</p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
